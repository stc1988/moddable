/*
 * Copyright (c) 2022  Moddable Tech, Inc.
 *
 *   This file is part of the Moddable SDK Tools.
 * 
 *   The Moddable SDK Tools is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 * 
 *   The Moddable SDK Tools is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 * 
 *   You should have received a copy of the GNU General Public License
 *   along with the Moddable SDK Tools.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import { FILE, TOOL } from "tool";

export default class extends TOOL {
	constructor(argv) {
		super(argv);

		this.sourcePath = null;
		this.outputDirectory = null;
		let argc = argv.length;
		for (let argi = 1; argi < argc; argi++) {
			let option = argv[argi], name, path;
			switch (option) {				
			case "-o":
				argi++;	
				if (argi >= argc)
					throw new Error("-o: no path!");
				name = argv[argi];
				if (this.outputDirectory)
					throw new Error("-o '" + name + "': too many output paths!");
				path = this.resolveDirectoryPath(name);
				if (!path)
					throw new Error("-o '" + name + "': path not found!");
				this.outputDirectory = path;
				break;

			default:
				name = argv[argi];
				if (this.sourcePath)
					throw new Error("'" + name + "': too many files!");
				path = this.resolveFilePath(name);
				if (!path)
					throw new Error("'" + name + "': file not found!");
				this.sourcePath = path;
				break;
			}
		}
		if (!this.sourcePath)
			throw new Error("no input file!");
	}

	run() {
		const source = this.readFileString(this.sourcePath);
		let flows = JSON.parse(source);

		flows = this.transformFlows(flows);

		const parts = this.splitPath(this.sourcePath);
		parts.extension = ".js";
		if (this.outputDirectory)
			parts.directory = this.outputDirectory;
		const outputPath = this.joinPath(parts);

		const output = new FILE(outputPath, "wb");
		output.writeString(flows);
		output.close();
	}

	transformFlows(flows) {
		const parts = [];

		// add global configuration node to start of list
		flows.unshift({
			type: "tab",
			id: "__config",
			name: "global config"
		});

		// set z for each node in global configuration flow
		flows.forEach(config => {
			if (("tab" !== config.type) && !config.z)
				config.z = "__config"; 
		});

		parts.push(`// auto-generated by nodered2mcu on ${Date()}`);
		parts.push(``);

		parts.push(`import "nodered";		// ensure globalThis.RED is available`);
		parts.push(`import Timer from "timer"`);
		parts.push(``);

		parts.push(`function build(flows, createFlow, createNode) {`);
		parts.push(`\tlet flow, node, nodes;`);

		flows.forEach(config => {
			if ("tab" !== config.type)
				return;

			parts.push(`\tflow = createFlow("${config.id}", "${config.name ?? ""}")`);

			const z = config.id;
			flows.forEach(config => {
				if (config.z !== z)
					return;

				const type = config.d ? "unknown" : config.type;
				parts.push(`\tcreateNode("${type}", "${config.id}", "${config.name}", flow);`) 
			});
		});

		parts.push(``) 

		parts.push(`\tflows = flows.values();`);
		flows.forEach(config => {
			if ("tab" !== config.type)
				return;

			parts.push(`\tflow = flows.next().value;	// ${config.id}`);
			parts.push(``);
			parts.push(`\tnodes = flow.nodes();`);

			const z = config.id;
			flows.forEach(config => {
				if (config.z !== z)
					return;

				parts.push(`\tnode = nodes.next().value;	// ${config.type}${config.d ? " (disabled)" : ""} - ${config.id}`);
				if (config.d)
					return;

				const {type, id, name, ...c} = {...config};
				delete c.x;
				delete c.y;
				delete c.z;

				try {
					this.prepareConfig(type, c);
					let configuration = ["{"];
					for (const name in c) {
						const value = c[name];
						if (("string" === typeof value) && value.startsWith("function ("))
							configuration.push(`\t\t${name}: ${value},`);
						else
							configuration.push(`\t\t${name}: ${JSON.stringify(value)},`);
					}
					
					configuration.push("\t}");
					configuration = configuration.join("\n");
					
					parts.push(`\tnode.onStart(${configuration});`) ;
					parts.push(``)
				}
				catch (e) {
					trace(`Error translating node ID "${id}, type "${type}", name "${name}": ${e}\n`);
					throw e;
				}
			});
		});

		parts.push(`}`) 
		parts.push(``) 

		parts.push(`export default Object.freeze({`);
		parts.push(`\tbuild,`);
		parts.push(`}, true);`);
		
		return parts.join("\n");
	}
	prepareConfig(type, config) {
		switch (type) {
			case "debug": {
				if ("jsonata" === config.targetType)
					throw new Error("unimplemented");

				const getter = [];
				getter.push(`function (msg) {`);
				if ("true" === config.complete)
					getter.push(`\t\t\tmsg;`);
				else
					getter.push(`\t\t\treturn msg.${config.complete};`);
				getter.push(`\t\t}`);
				config.getter = getter.join("\n");

				if (config.tostatus) {
					if ("auto" === config.statusType)
						config.statusVal = config.getter;
					else if ("msg" === config.statusType) {
						getter.length = 1;
						getter.push(`\t\t\treturn msg.${config.statusVal};`);
						getter.push(`\t\t}`);
						config.statusVal = getter.join("\n");
					}
					else
						throw new Error(`unimplemented statusType: ${config.statusType}`); 
				}
			} break;

			case "function": {
				const params = "node, context, flow, global, libs"

				let libs = "";
				if (config.libs.length) {
					libs = [];
					for (let i = 0; i < config.libs.length; i++) {
						const item = config.libs[i];
						libs[i] = item.var;
						config.libs[i] = item.module;
					}
					libs = `const [${libs.join(", ")}] = libs;\n`
				}
				else
					delete config.libs;

				if (config.func)
					config.func = `function (msg, ${params}) {\n${libs}${config.func}\n}`;
				else 
					delete config.func;

				if (config.initialize)
					config.initialize = `function (${params}) {\n${libs}${config.initialize}\n}`;
				else
					delete config.initialize;

				delete config.finalize;
				delete config.outputs;
				delete config.noerr;
				} break;

			case "inject": {
				if (config.chrontab)
					throw new Error("chrontab unimplemented");

				const trigger = [];
				trigger.push(`function () {`);
				trigger.push(`\t\t\tconst msg = {};`);

				config.props.forEach(property => {
					const name = property.p;
					const type = ("payload" === name) ? config.payloadType : property.vt;
					let value = ("payload" === name) ? config.payload : property.v;
					value = this.resolveValue(type, value);
					trigger.push(`\t\t\tmsg.${name} = ${value};`);
				});

				trigger.push(`\t\t\tthis.send(msg);`);
				trigger.push(`\t\t}`);
				config.trigger = trigger.join("\n");

				let delay;
				if (config.once)
					delay = config.once ? parseFloat(config.onceDelay) * 1000 : 0;
				const repeat = config.repeat ? parseFloat(config.repeat) * 1000 : 0;
				if ((undefined !== delay) || (0 !== repeat)) {
					const initialize = [];
					initialize.push(`function () {`);

					if (repeat)
						initialize.push(`\t\t\tTimer.set(() => this.trigger(), ${delay ?? 0}, ${repeat});`);
					else
						initialize.push(`\t\t\tTimer.set(() => this.trigger(), ${delay});`);

					initialize.push(`\t\t}`);
					config.initialize = initialize.join("\n");
				}

				delete config.props;
				delete config.topic;
				delete config.repeat;
				delete config.crontab;
				delete config.once;
				delete config.onceDelay;
				delete config.payload;
				delete config.payloadType;
				} break;

			case "change": {
				const change = [];
				change.push(`function (msg) {`);

				config.rules.forEach(rule => {
					if ("set" === rule.t) {
						const value = this.resolveValue(rule.tot, rule.to);
						if ("msg" === rule.pt)
							change.push(`\t\t\tmsg.${rule.p} = ${value};`);
						else if ("flow" === rule.pt)
							change.push(`\t\t\tthis.flow.set("${rule.p}", ${value});`);
						else if ("global" === rule.pt)
							change.push(`\t\t\tglobalContext.set("${rule.p}", ${value});`);
						else
							throw new Error(`unexpected set type: ${pt}`);
					}
					else if ("move" === rule.t) {
						const value = this.resolveValue(rule.pt, rule.p);
						if ("msg" === rule.tot)
							change.push(`\t\t\tmsg.${rule.to} = ${value};`);
						else if ("flow" === rule.tot)
							change.push(`\t\t\tthis.flow.set("${rule.to}", ${value});`);
						else if ("global" === rule.tot)
							change.push(`\t\t\tglobalContext.set("${rule.to}", ${value});`);
						else
							throw new Error(`unexpected move type: ${pt}`);
					}

					if (("delete" === rule.t) || ("move" == rule.t)) {
						if ("msg" === rule.pt)
							change.push(`\t\t\tdelete msg.${rule.p}`);
						else if ("flow" === rule.pt)
							change.push(`\t\t\tthis.flow.delete("${rule.p}");`);
						else if ("global" === rule.pt)
							change.push(`\t\t\tglobalContext.delete("${rule.p}");`);
						else
							throw new Error(`unexpected delete type: ${pt}`);
					}
				});

				change.push(`\t\t\treturn msg;`);
				change.push(`\t\t}`);
				config.onMessage = change.join("\n");

				delete config.rules;
				delete config.action;
				delete config.property;
				delete config.from;
				delete config.to;
				delete config.reg;
			} break;

			case "split": {
				if (config.stream || ("len" !== config.arraySpltType) || ("str" !== config.spltType))
					throw new Error("unimplemented split option");

				config.arraySplt = parseInt(config.arraySplt);
			} break;

			case "range": {
				const maxin = parseFloat(config.maxin);
				const maxout = parseFloat(config.maxout);
				const minin = parseFloat(config.minin);
				const minout = parseFloat(config.minout);
				const scale = (maxout - minout) / (maxin - minin);
				const action = config.action;
				const property = config.property;
				const round = config.round;

				const range = [];
				range.push(`function (msg) {`);
				range.push(`\t\t\tlet value = msg.${property};`);
				if ("clamp" === action) {
					range.push(`\t\t\tif (value < ${minin})`);
					range.push(`\t\t\t\tvalue = ${minin};`);
					range.push(`\t\t\tif (value > ${maxin})`);
					range.push(`\t\t\t\tvalue = ${maxin};`);
				}
				else if ("roll" === action) {
					const divisor = maxin - minin;
					range.push(`\t\t\tvalue = ((value - ${minin}) % ${divisor} + ${divisor}) % ${divisor} + ${minin};`);
				}
				range.push(`\t\t\tvalue = ((value - ${minin}) * ${scale}) + ${minout};`);
				if (round)
					range.push(`\t\t\tmsg.${property} = Math.round(value);`);
				else				
					range.push(`\t\t\tmsg.${property} = value;`);
				range.push(`\t\t\treturn msg;`);
				range.push(`\t\t}`);
				
				config.onMessage = range.join("\n");

				delete config.maxin;
				delete config.maxout;
				delete config.minin;
				delete config.minout;
				delete config.action;
				delete config.property;
				delete config.round;
			} break;

			case "switch": {
				if (config.repair)
					throw new Error("unimplemented");

				const value = this.resolveValue(config.propertyType, config.property);
				const checkAll = "true" === config.checkall;
				const outputCount = config.wires.length;
				const hasElse = config.rules.find(config => "else" === config.t);
				const usesPrevious = config.rules.find(config => ("prev" === config.v2t) || ("prev" == config.vt));

				const doSwitch = [];
				doSwitch.push(`function (msg) {`);
				doSwitch.push(`\t\t\tlet value = ${value};`);
				doSwitch.push(`\t\t\tconst result = new Array(${"null, ".repeat(outputCount)});`);
				if (usesPrevious) {
					doSwitch.push(`\t\t\tconst previous = this.previous;`);
					doSwitch.push(`\t\t\tthis.previous = value;`);
				}
				if (checkAll && hasElse)
					doSwitch.push(`\t\t\tlet first = true;`);

				config.rules.map((config, index) => {
					let test;

					if ("istype" === config.t) {
						switch (config.v) {
							case "string":
							case "number":
							case "boolean":
							case "object":
							case "undefined":
							case "null":
								test = `${config.v} === typeof value`;
								break;
							case "array":
								test = `Array.isArray(value)`;
								break;
							case "json":
								doSwitch.push(`\t\t\ttry {`);
								doSwitch.push(`\t\t\t\tJSON.parse(value);`);
								doSwitch.push(`\t\t\t\tvalue = true;`);
								doSwitch.push(`\t\t\t}`);
								doSwitch.push(`\t\t\tcatch {`);
								doSwitch.push(`\t\t\t\tvalue = false;`);
								doSwitch.push(`\t\t\t}`);
								test = `value`;
								break;
							default:
								throw new Error(`unimplemented istype: ${config.v}`);
						}
					}
					else {
						const v = this.resolveSwitch(config.vt, config.v);
						const v2 = this.resolveSwitch(config.v2t, config.v2);

						switch (config.t) {
							case "btwn":
								test = `(${v} <= value) && (value <= ${v2})`;
								break;
							case "eq":
								test = `value == ${v}`;
								break;
							case "neq":
								test = `value != ${v}`;
								break;
							case "lt":
								test = `value < ${v}`;
								break;
							case "lte":
								test = `value <= ${v}`;
								break;
							case "gt":
								test = `value > ${v}`;
								break;
							case "gte":
								test = `value >= ${v}`;
								break;
							case "true":
								test = `true === value`;
								break;
							case "false":
								test = `false === value`;
								break;
							case "null":
								test = `null === value`;
								break;
							case "nnull":
								test = `null !== value`;
								break;							
							case "hask":
								test = `("object" === typeof value) && (${v} in value)`;
								break;							
							case "else":
								if (checkAll) {
									doSwitch.push(`\t\t\tif (first) {`);
									doSwitch.push(`\t\t\t\tresult[${index}] = msg;`);
								}
								else {
									doSwitch.push(`\t\t\t{`);
									doSwitch.push(`\t\t\tresult[${index}] = msg;`);	
								}
								break;
							default:
								throw new Error(`unimplemented rule: ${config.t}`);
						}
					}

					if (test) {
						doSwitch.push(`\t\t\tif (${test}) {`);
						doSwitch.push(`\t\t\t\tresult[${index}] = msg;`);
						if (!checkAll)
							doSwitch.push(`\t\t\t\treturn result;`);		//@@
						if (checkAll)
							doSwitch.push(`\t\t\t\tfirst = false;`);
					}
					doSwitch.push(`\t\t\t}`);
				});

				doSwitch.push(`\t\t\treturn result;`);
				doSwitch.push(`\t\t}`);
				config.onMessage = doSwitch.join("\n");

				delete config.property;
				delete config.propertyType;
				delete config.rules;
				delete config.checkall;
				delete config.repair;
				delete config.outputs;
			} break;

			case "json": {
				if (!config.action)
					delete config.action;

				const property = [];
				property.push(`function (msg, value) {`);
				property.push(`\t\t\tif (undefined === value)`);
				property.push(`\t\t\t\treturn msg.${config.property};`);
				property.push(`\t\t\tmsg.${config.property} = value;`);
				property.push(`\t\t}`);
				config.property = property.join("\n");
			} break;

			case "rpi-gpio in": {
				if (config.read || parseFloat(config.debounce))
					throw new Error("unimplemented");
				
				config.pin = parseInt(config.pin);
			} break;

			case "rpi-gpio out": {
				config.pin = parseInt(config.pin);

				if ("pwm" === config.out) 
					config.freq = ("" === config.freq) ? 0 : parseFloat(config.freq);
				else
					delete config.freq;
				if (config.level)
					config.level = parseInt(config.level);
				else
					delete config.level;

			} break;
		}
	}
	resolveValue(type, value) {
		switch (type) {
			case "bool":
				return "true" === value;
			case "date":
				return "Date.now()";
			case "json":
				return value;
			case "num":
				return parseFloat(value);
			case "str":
				return `"${value ?? ""}"`;
			case "msg":
				return `msg.${value}`;
			case "flow":
				return `this.flow.get("${value}")`;
			case "global":
				return `globalContext.get("${value}")`;
			default:
				throw new Error(`cannot resolve type "${type}"`);
		}
	}
	resolveSwitch(type, value) {
		if (!type)
			return;

		if ("prev" === type)
			return `previous`;

		return this.resolveValue(type, value);
	}
}
